
# 寄存器
    8086处理器内部有8个16位的通用寄存器，都是由16比特组成的，并分别被命名为AX、BX、CX、DX、SI、DI、BP、SP

    这8个寄存器中的前4个，即AX、BX、CX和DX，又各自可以拆分成两个8位的寄存器来使用，总共可以提供8个8位的寄存器AH、AL、BH、BL、CH、CL、DH和DL。这样一来，当需要在寄存器和寄存器之间，或者寄存器和内存单元之间进行8位的数据传送或者算术逻辑运算时，使用它们就很方便

    数据段寄存器：DS
    代码段寄存器：CS
    附加段寄存器：ES
    栈段寄存器  ：SS
    8086内部有4个段寄存器。其中，CS是代码段寄存器，DS是数据段寄存器，ES是附加段(Extra Segment)寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS指向一个，ES指向另一个。可以在指令中指定使用DS和ES中的哪一个，如果没有指定，则默认使用DS。SS是栈段(Stack Segment)寄存器，以后会讲到，而且非常重要

    指令指针寄存器：IP
    IP是指令指针(Instruction Pointer)寄存器，它只和CS一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS保存代码段的段地址，IP则指向段内偏移。这样，由CS和IP共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后，处理器会自动根据当前指令的长度来改变IP的值，使它指向下一条指令

    8086内部有一个6字节的指令预取队列
    处理器能够自动运行，这是控制器的功劳。为了加快指令执行速度，8086内部有一个6字节的指令预取队列，在处理器忙着执行那些不需要访问内存的指令时，指令预取部件可以趁机访问内存预取指令。这时，多达6字节的指令流可以排队等待解码和执行

    标志寄存器
    在x86-64体系结构中，RFLAGS寄存器是64位的，其中各个位的功能如下：

    CF (Carry Flag)：进位标志，记录了最近一次算术运算是否产生了进位或借位。

    PF (Parity Flag)：奇偶标志，记录了最近一次操作结果中低8位的奇偶性。

    AF (Auxiliary Carry Flag)：辅助进位标志，记录了最近一次十六进制数运算是否产生了进位或借位。

    ZF (Zero Flag)：零标志，记录了最近一次操作结果是否为零。

    SF (Sign Flag)：符号标志，记录了最近一次操作结果的符号。

    TF (Trap Flag)：陷阱标志，在单步执行模式下用于调试目的。

    IF (Interrupt Enable Flag)：中断使能标志，在置为1时允许处理器响应外部中断请求。

    DF (Direction Flag)：方向标志，控制字符串操作指令执行时数据传输的方向（0表示递增，1表示递减）。

    OF (Overflow Flag)：溢出标志，记录了最近一次有符号整数运算是否发生溢出。

    IOPL[1:0] (I/O Privilege Level Field): I/O 特权级字段，在特殊环境下用于控制对I/O端口的访问权限。

    NT (Nested Task Flag): 嵌套任务标志，在发生任务切换时用于支持任务的层次结构。

    RF (Resume Flag): 恢复标志，在处理器从断点处恢复执行时使用。

    VM (Virtual-8086 Mode Flag): 虚拟-8086模式标志，控制处理器是否以虚拟8086模式运行。

    AC (Alignment Check Flag): 对齐检查标志，用于保证数据对齐的正确性。

    VIF (Virtual Interrupt Flag)：虚拟中断标志，在处理器以虚拟8086模式运行时用于支持中断处理。

    VIP (Virtual Interrupt Pending)：虚拟中断挂起标志，在处理器以虚拟8086模式运行时用于指示有待处理的中断请求。

    ID (ID Flag)：识别标志，指示处理器是否支持CPUID指令。

## 标号
    标号代表某一行的地址



## 语法

### x86
    into、int3、intn、iret、cli、sti、hlt、not和test等。

    iret：中断返回指令
        IRET 是 x86 架构中的一条指令，用于从中断或异常处理程序返回到先前被中断的代码位置。它的作用是恢复被中断时的上下文，并继续执行被中断的程序。

        IRET 指令执行时会从堆栈中弹出之前保存的标志寄存器 (EFLAGS)、指令指针 (EIP) 和段选择子等内容，并将控制权返回到被中断的程序。

        在保护模式下，IRET 也会还原任务状态段 (Task State Segment, TSS) 中的相关信息以支持任务切换和多任务处理。

        总而言之，IRET 指令是用于从中断或异常处理过程返回到原始执行点并恢复正常执行流程的关键指令

    sti:设置中断标志位。它通常用于打开处理器的中断功能
            在大多数x86架构的汇编语言中，STI指令没有任何操作数
            执行STI指令后，处理器会将EFLAGS寄存器中的IF（Interrupt Flag）位设置为1，以允许外部中断的响应。这样，当有可屏蔽中断发生时，处理器会检查IF位是否为1，
        并根据情况进入相应的中断服务 程序。需要注意的是，在使用STI指令时需要小心，并确保在适当的时候关闭中断标志位（使用CLI指令）。不正确地操作中断标志位可能
        导致意外的结果或安全问题。另外，请注意不同体系结构和编译器可能具有不同的汇编语言规范和特性，因此建议参考特定平台和文档来了解精确的用法和行为。


    CLI:用于清除中断标志位。它通常用于禁用处理器的中断功能
        在大多数x86架构的汇编语言中，CLI指令没有任何操作数
        执行CLI指令后，处理器会将EFLAGS寄存器中的IF（Interrupt Flag）位设置为0，以禁止外部中断的响应。这样，当有可屏蔽中断发生时，处理器不会进入相应的中断服务程序。
        需要注意的是，在使用CLI指令时需要小心，并确保在适当的时候重新启用中断标志位（使用STI指令）。正确地管理和控制中断标志位对于确保系统的正常运行和安全性至关重要。
        另外，请注意不同体系结构和编译器可能具有不同的汇编语言规范和特性，因此建议参考特定平台和文档来了解精确的用法和行为。

    x86处理器指令，如in、out、shl、shr、rol、ror、jmp、call、ret等

    shl:shl 是 x86 汇编指令中的一个逻辑左移指令（Shift Left）。它将给定操作数向左移动指定的位数，用零填充右侧空出来的位
        shl 的语法为：
            shl destination, count
        其中 destination 是要进行左移操作的目标操作数，可以是寄存器或内存位置；count 是左移的位数，可以是立即数或者存储在 CL 寄存器中。需要注意的是，对于 32 位和 64 位操作数，最多只能进行 31 位的左移。

    shr:shr 是 x86 汇编指令中的一个逻辑右移指令（Shift Right）。它将给定操作数向右移动指定的位数，用零填充左侧空出来的位
        shr 的语法为：
            shr destination, count
        其中 destination 是要进行右移操作的目标操作数，可以是寄存器或内存位置；count 是右移的位数，可以是立即数或者存储在 CL 寄存器中。需要注意的是，对于 32 位和 64 位操作数，最多只能进行 31 位的右移。



    rol:rol 是 x86 汇编指令中的循环左移指令（Rotate Left）。它将给定操作数向左循环移动指定的位数
        rol 的语法为：
            rol destination, count
        其中 destination 是要进行循环左移操作的目标操作数，可以是寄存器或内存位置；count 是循环左移的位数，可以是立即数或者存储在 CL 寄存器中。需要注意的是，对于 32 位和 64 位操作数，最多只能进行 31 位的循环左移

    ror:ror 是 x86 汇编指令中的循环右移指令（Rotate Right）。它将给定操作数向右循环移动指定的位数
        ror 的语法为：
            ror destination, count
        其中 destination 是要进行循环右移操作的目标操作数，可以是寄存器或内存位置；count 是循环右移的位数，可以是立即数或者存储在 CL 寄存器中。需要注意的是，对于 32 位和 64 位操作数，最多只能进行 31 位的循环右移

    jmp:jmp 是汇编语言中的跳转指令，用于无条件地将控制流转移到程序中的其他位置
        jmp 的语法为：
            jmp destination
        其中 destination 可以是一个标号（通常对应于代码中的某个位置），也可以是一个寄存器或内存地址。执行 jmp 指令后，程序将会直接跳转到 destination 所指定的位置，并继续执行该位置处的指令

    jne:jne 是汇编语言中的条件跳转指令，用于在满足特定条件时执行跳转操作。它的全称是 "Jump if Not Equal"，意思是如果前一个比较指令的结果不等，则进行跳转
        jne 的语法为：
            jne destination
        其中 destination 可以是一个标号（通常对应于代码中的某个位置），也可以是一个寄存器或内存地址。执行 jne 指令后，程序将会根据前一个比较指令的结果来决定是否进行跳转。如果比较结果不等，则跳转到 destination 所指定的位置继续执行；如果相等，则继续顺序执行下一条指令。

        以下是一些示例：
                cmp eax, ebx   ; 将 eax 和 ebx 进行比较
                jne not_equal  ; 如果不相等则跳转到标号为 "not_equal" 的位置
                ; 如果相等，则继续执行下面的指令

                test ecx, ecx  ; 将 ecx 和自身进行按位与操作
                jne nonzero    ; 如果结果非零则跳转到标号为 "nonzero" 的位置
                ; 如果为零，则继续执行下面的指令

                jmp next       ; 无条件跳转到标号为 "next" 的位置

                not_equal:
                    ...
                    jmp end     ; 跳转到标号为 "end" 的位置

                nonzero:
                    ...
                    jmp end     ; 跳转到标号为 "end" 的位置

                next:
                    ...
                end:

    call:call 是汇编语言中的过程调用指令，用于将控制权转移至一个指定的子程序（过程或函数）并在子程序执行完毕后返回
        call 的语法为：
            call destination
        其中 destination 可以是一个标号（通常对应于代码中的某个位置），也可以是一个寄存器或内存地址。执行 call 指令后，当前指令的下一条指令地址会被保存到栈中，并将控制权转移到 destination 所指定的位置开始执行子程序

        以下是一个示例：
            call subroutine  ; 调用名为 "subroutine" 的子程序
            ; 执行该子程序的代码

            jmp next         ; 子程序执行完毕后跳转到标号为 "next" 的位置

            subroutine:
                ...
                ret           ; 返回到调用点

            next:
                ...

    ret:ret 是汇编语言中的指令，用于从子程序（过程或函数）返回到调用点。它通常与 call 指令一起使用，完成过程的调用和返回操作
        ret 的语法为：
            ret
        执行 ret 指令时，它会从栈中弹出保存的返回地址，并将控制权转移到该地址所指定的位置继续执行代码

        以下是一个示例：
            call subroutine  ; 调用名为 "subroutine" 的子程序

            ...

            subroutine:
                ...
                ret           ; 返回到调用点
        在上面的示例中，通过使用 call 指令调用了名为 "subroutine" 的子程序。当遇到 ret 指令时，它会从栈中弹出之前保存的返回地址，并将控制权转移到该地址所指定的位置，继续执行后续的代码。

        通过正确使用 call 和 ret 指令配合，我们可以实现过程/函数的调用和返回，在程序中实现模块化和重复利用代码


        